title: 程序数据区的内存分配
date: 2019-09-24 06:59:00
categories: 技术
tags: [C++]
---


一个由C/C++编译的程序占用的数据区内存分为以下几个部分：

### 栈区 

  * 自动分配，随着作用域退出而释放
  * 存放函数的参数值，局部变量的值等
  * 后进先出，内存是连续的
  * 向内存地址减小的方向增长
  * 分配效率高
  * 可分配空间小
<!--more-->
### 堆区 

  * 程序员分配，并在适当时刻释放。否则，程序将在结束后释放
  * 频繁的分配释放会造成内存空间的不连续，从而产生大量的碎片，使程序效率降低
  * 向内存地址增大的方向增长
  * 可分配空间大

### 静态(全局)存储区 
   * 编译时即分配内存，程序结束后释放内存
   * 存放**全局变量**、**静态变量**和**常量**(常变量和字符串常量，一经初始化，**不可修改**)
   * 如不进行显式初始化，则**默认初始化为0**   
--------------------------------------------
### 举例
#### 例1
  ```c
  //main.cpp 
  int a = 0; //全局初始化区 
  char *p1; //全局未初始化区 
  void main() 
  { 
     int b; //栈 
     char s[] = "abc"; //栈 
     char *p2; //栈 
     char *p3 = "123456"; //123456在常量区，p3在栈上。 
     static int c =0;     //全局（静态）初始化区 
     p1 = (char *)malloc(10); 
     p2 = (char *)malloc(20);//分配得来得10和20字节的区域就在堆区。 
     strcpy(p1, "123456");   //123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
  }
  ``` 
#### 例2
  ```C
int main()
{
    char* p = "Hello World";//Hello World在常量区，p在栈上
    char a[] = "Hello World2";//栈
   // p[2] ='A'; 错误
    a[2] ='A';
    char* p1 = "Hello World";

    return 0;
}
  ```
程序中`p`是在栈上的，`Hello World`在常量区，因此`p[2] ='A';`是错误的。虽然通过`p[2]`可以访问静态存储区中字符`l`所在的存储单元，但由于`Hello World`是字符串常量，所以程序运行时，会报告内存错误。并且，此时`p`和`p1`里面保存的地址可能是完全相同的。
![Snipaste_2019-09-26_09-54-45.jpg](https://sudo.plus/usr/uploads/2019/09/3780562305.jpg)
#### 例3
```c
char* f1()
{ 
 char a;
 char* p = &a;
 return p;
}

char* f2（）
{ 
  char* p = new char[4];
  return p;
}
```
**f1**和**f2**都是返回某个存储空间的地址，二者有何区别呢？
**f1**返回的是一个分配在栈上的存储空间，它的生命周期在**f1**调用结束时，就被释放掉了。所以，当调用**f1**时，如果程序中有下面的语句：
```c
char* p;
p = f1();
*p ='a';
```
编译并不会报错，但在运行时会发生异常。
因为，程序对不应该操作的内存（即已经释放掉的空间）进行了操作。
但是，相比之下，**f2**不会有问题。因为，**new**是在堆中申请存储空间，一旦申请成功，除非将其**delete**或者程序终结，这块内存将一直存在。

但是使用堆内存要避免下面的事情发生：
```c
void f（）
{
  char * p;
  p =（char*）new char[100];
}
```
这段虽然申请了堆内存，p保存了堆内存的首地址。但p是栈变量，当函数调用结束时p变量消失。也就是说，没有变量存储这块堆内存的首地址，当前程序将无法再使用那块堆内存。但是，这块堆内存却一直标识被当前程序所使用，其他程序也无法申请到，这就是发生了**内存泄漏**。

### 总结
对于堆区、栈区和静态存储区它们之间最大的不同在于：
栈的生命周期很短暂，堆区和静态存储区的生命周期与程序的生命周期相同（如果不**delete**）。